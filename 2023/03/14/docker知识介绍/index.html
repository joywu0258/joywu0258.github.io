<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker从零开始 | Ashley的个人博客空间</title><meta name="author" content="joywu"><meta name="copyright" content="joywu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概括容器背景程序运行的基础环境我们的程序首先在开发环境开发，然后需要部署到测试环境交给测试人员测试，最后需要由运维人员部署到生产环境正式运行，在这个过程中任何一个环境如果和其他环境不一致，则会出现开发阶段能运行的程序在测试阶段或生产阶段不能够正常运行，这就是“软件跨环境迁移”问题。 JavaEE程序依赖的基础环境：JDK、tomcat、数据库、中间件、操作系统、配置文件（代码配置、JDK配置、">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker从零开始">
<meta property="og:url" content="http://ashleyye.top/2023/03/14/docker%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Ashley的个人博客空间">
<meta property="og:description" content="基本概括容器背景程序运行的基础环境我们的程序首先在开发环境开发，然后需要部署到测试环境交给测试人员测试，最后需要由运维人员部署到生产环境正式运行，在这个过程中任何一个环境如果和其他环境不一致，则会出现开发阶段能运行的程序在测试阶段或生产阶段不能够正常运行，这就是“软件跨环境迁移”问题。 JavaEE程序依赖的基础环境：JDK、tomcat、数据库、中间件、操作系统、配置文件（代码配置、JDK配置、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-14T10:00:00.000Z">
<meta property="article:modified_time" content="2023-08-18T13:58:20.579Z">
<meta property="article:author" content="joywu">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ashleyye.top/2023/03/14/docker%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker从零开始',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-18 21:58:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ashley的个人博客空间"><span class="site-name">Ashley的个人博客空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker从零开始</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-14T10:00:00.000Z" title="发表于 2023-03-14 18:00:00">2023-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-18T13:58:20.579Z" title="更新于 2023-08-18 21:58:20">2023-08-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基本概括"><a href="#基本概括" class="headerlink" title="基本概括"></a>基本概括</h1><h2 id="容器背景"><a href="#容器背景" class="headerlink" title="容器背景"></a>容器背景</h2><h3 id="程序运行的基础环境"><a href="#程序运行的基础环境" class="headerlink" title="程序运行的基础环境"></a>程序运行的基础环境</h3><p>我们的程序首先在开发环境开发，然后需要部署到测试环境交给测试人员测试，最后需要由运维人员部署到生产环境正式运行，<strong>在这个过程中任何一个环境如果和其他环境不一致</strong>，则会出现开发阶段能运行的程序在测试阶段或生产阶段不能够正常运行，这就是“<strong>软件跨环境迁移</strong>”问题。</p>
<p>JavaEE程序依赖的基础环境：JDK、tomcat、数据库、中间件、操作系统、配置文件（代码配置、JDK配置、tomcat配置、操作系统配置）等等</p>
<p><img src="/img/image-20230713171331829.png" alt="image-20230713171331829"></p>
<p>因此<strong>面临的问题</strong></p>
<ul>
<li>复杂的系统运维<ul>
<li>开发环境、测试环境和生产环境的很难保持高度一致，由环境不一致而导致的软件故障，很难解决</li>
</ul>
</li>
<li>软件交付和部署流程繁琐<ul>
<li>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行</li>
</ul>
</li>
<li>服务器扩缩容流程繁琐、成本巨大<ul>
<li>例如：微博业务面临的问题：<a target="_blank" rel="noopener" href="https://myslide.cn/slides/331">https://myslide.cn/slides/331</a></li>
</ul>
</li>
</ul>
<h3 id="解决方案：容器化"><a href="#解决方案：容器化" class="headerlink" title="解决方案：容器化"></a>解决方案：容器化</h3><p>于是它出现了，Docker可以让开发者构建应用程序时，将应用程序与其所依赖的环境一起打包到一个容器中，然后一一交付整个环境而不仅仅是代码。</p>
<p>这样一个带环境的程序包就是一个容器，容器可以解决软件跨环境迁移的问题。</p>
<p><img src="/img/image-20230713171405557.png" alt="image-20230713171405557"></p>
<h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><p><strong>开源容器引擎：</strong>docker是基于Go语言实现的开源容器引擎。2013年出现，DotCloud公司开发（现在的Docker公司）</p>
<p><img src="/img/image-20230713171439660.png" alt="image-20230713171439660"></p>
<p><img src="/img/image-20230713171454045.png" alt="image-20230713171454045"></p>
<p><strong>集装箱：</strong>可以将每个容器看成是一个集装箱，包含程序以及程序运行所依赖的所有环境和配置。</p>
<p><img src="/img/image-20230713171526787.png" alt="image-20230713171526787"></p>
<ul>
<li><strong>标准化：</strong>每个容器都是标准化、可移植的，因为他们直接运行在宿主机的内核上</li>
<li><strong>隔离：</strong>容器互相隔离，互不干扰，独立运行</li>
<li><strong>高性能：</strong>容器性能开销极低，可以实现分钟级甚至秒级的部署和启动</li>
<li><strong>版本：</strong>CE（Community Edition：社区版）和EE（Enterprise Edition：企业版）</li>
</ul>
<h2 id="Docker理念"><a href="#Docker理念" class="headerlink" title="Docker理念"></a>Docker理念</h2><p>Build，Ship and Run Any App，Anywhere</p>
<p>在任何地方构建、发布并运行任何应用程序（一次封装，到处运行）</p>
<h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Docker可以运行在Windows、Mac、CentOS、Ubuntu等操作系统上</p>
<p>Docker支持以下的CentOS版本：</p>
<ul>
<li>CentOS 7 (64-bit)</li>
<li>CentOS 6.5 (64-bit) 或更高的版本</li>
</ul>
<p>目前，CentOS 仅发行版本中的内核支持 Docker</p>
<p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</p>
<p>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p>
<h2 id="CentOS7-镜像"><a href="#CentOS7-镜像" class="headerlink" title="CentOS7 镜像"></a>CentOS7 镜像</h2><p>阿里云站点：<a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></p>
<p>每个链接都包括了镜像文件的地址、类型及版本号等信息</p>
<p>选择当前国家资源区站点下载，获取资源速度比较快</p>
<p>step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载</p>
<p>各个版本的ISO镜像文件说明：</p>
<p>CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐）</p>
<p>CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）</p>
<p>CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版</p>
<p>CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版</p>
<p>CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少</p>
<p>CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统）</p>
<h2 id="查看系统内核"><a href="#查看系统内核" class="headerlink" title="查看系统内核"></a>查看系统内核</h2><p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<h2 id="查看CentOS版本信息"><a href="#查看CentOS版本信息" class="headerlink" title="查看CentOS版本信息"></a>查看CentOS版本信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

<h1 id="CentOS7安装Docker"><a href="#CentOS7安装Docker" class="headerlink" title="CentOS7安装Docker"></a>CentOS7安装Docker</h1><h2 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h2><p>yy -utils提供了yy-config-manager相关功能，device-mapper-persistent-data和lvm2是设备映射器驱动程序所需要的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">               device-mapper-persistent-data \</span><br><span class="line">               lvm2</span><br></pre></td></tr></table></figure>

<h2 id="Docker下载"><a href="#Docker下载" class="headerlink" title="Docker下载"></a>Docker下载</h2><p>Docker下载地址</p>
<p>推荐阿里云</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h2 id="更新yum软件包索引"><a href="#更新yum软件包索引" class="headerlink" title="更新yum软件包索引"></a>更新yum软件包索引</h2><p>我们在更新或配置yum源之后，通常都会使用yum makecache 生成缓存，这个命令是将软件包信息提前在本地缓存一份，用来提高搜索安装软件的速度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<h2 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker自启"><a href="#Docker自启" class="headerlink" title="Docker自启"></a>Docker自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h2 id="版本验证"><a href="#版本验证" class="headerlink" title="版本验证"></a>版本验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><strong>允许当前用户直接运行 <code>docker</code> 命令</strong></p>
<p>需要将当前用户加入 <code>docker</code> 用户组。这样每次运行 <code>docker</code> 命令的时候，就不需要加 <code>sudo</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_name</span><br></pre></td></tr></table></figure>

<h1 id="CentOS6-8安装docker"><a href="#CentOS6-8安装docker" class="headerlink" title="CentOS6.8安装docker"></a>CentOS6.8安装docker</h1><h2 id="安装epel"><a href="#安装epel" class="headerlink" title="安装epel"></a>安装epel</h2><p>docker依赖EPEL库，首先要确保已经安装epel仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y docker-io</span><br></pre></td></tr></table></figure>

<h2 id="安装后的配置文件"><a href="#安装后的配置文件" class="headerlink" title="安装后的配置文件"></a>安装后的配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/docker</span><br></pre></td></tr></table></figure>

<h2 id="启动Docker-1"><a href="#启动Docker-1" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h2 id="版本验证-1"><a href="#版本验证-1" class="headerlink" title="版本验证"></a>版本验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><strong>允许当前用户直接运行 <code>docker</code> 命令</strong></p>
<p>需要将当前用户加入 <code>docker</code> 用户组。这样每次运行 <code>docker</code> 命令的时候，就不需要加 <code>sudo</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_name</span><br></pre></td></tr></table></figure>

<h1 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum remove -y docker-ce</span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/img/image-20230713171626649.png" alt="image-20230713171626649"></p>
<h2 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h2><p>Docker由三部分组成：Client客户端、DOCKER_HOST docker主机、Registry 镜像仓库服务器</p>
<ul>
<li>DOCKER_HOST：docker主机<ul>
<li>docker daemon：docker安装后，会以守护进程的形式存在，也就是后台运行的进程</li>
<li>Images：镜像：镜像可以用来创建 docker 容器，一个镜像可以创建很多容器</li>
<li>Containers：容器：镜像和容器的关系类似面向对象设计中的类和对象，镜像是容器的模板，容器是基于镜像创建出来的。容器可以被创建、启动、停止、删除等等。</li>
</ul>
</li>
<li>Registry：镜像仓库服务器 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a><ul>
<li>一个 docker Registry（仓库注册服务器） 中可以包含多个Repository（仓库）；每个仓库可以包含多个标签&#x2F;版本（Tag）；每个标签对应一个镜像。</li>
<li>仓库分为公开仓库（Public）和私有仓库（Private）两种形式<ul>
<li>公开仓库就是docker官方仓库</li>
<li>私有仓库是自己搭建的docker私服</li>
</ul>
</li>
</ul>
</li>
<li>Client：docker终端<ul>
<li>安装好docker中，同时包含了docker客户端，客户端负责执行docker命令，发送给docker主机中的docker守护进程，例如：从仓库下载镜像，通过镜像创建容器等等。</li>
</ul>
</li>
</ul>
<h1 id="容器镜像服务"><a href="#容器镜像服务" class="headerlink" title="容器镜像服务"></a>容器镜像服务</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>从docker的官方镜像仓库服务器上下载docker的镜像速度很慢，因此我们可以配置国内的<strong>容器镜像服务</strong>，提升docker镜像的下载速度。</p>
<ul>
<li>阿里云</li>
<li>腾讯云</li>
<li>网易云</li>
</ul>
<h2 id="开通镜像服务"><a href="#开通镜像服务" class="headerlink" title="开通镜像服务"></a>开通镜像服务</h2><p>登录阿里云，搜索“<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务</a>”，获取加速地址</p>
<p><img src="/img/image-20230713171648266.png" alt="image-20230713171648266"></p>
<p><img src="/img/image-20230713171719669.png" alt="image-20230713171719669"></p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h1><p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>流程原理： 首先在docker主机查找hello-world的镜像文件，如果本地不存在镜像文件，则从镜像仓库下载（pulling from library&#x2F;hello-world）。</p>
<p>以镜像为模板创建docker容器并运行</p>
<p><img src="/img/image-20230713171849783.png" alt="image-20230713171849783"></p>
<p><strong>没有配置镜像加速器的结果：</strong></p>
<p>首先在docker主机查找hello-world的镜像文件，如果本地不存在镜像文件，则从镜像仓库下载。</p>
<p>因为docker官方的镜像仓库国内无法访问，所以访问超时（Timeout）</p>
<p><img src="/img/image-20230713171905219.png" alt="image-20230713171905219"></p>
<h1 id="run的工作流程"><a href="#run的工作流程" class="headerlink" title="run的工作流程"></a>run的工作流程</h1><p><img src="/img/image-20230713171945259.png" alt="image-20230713171945259"></p>
<h1 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h1><p>版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>帮助文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --help #列出所有的docker命令</span><br><span class="line">docker run --help #列出某一个docker命令的详细信息</span><br></pre></td></tr></table></figure>

<p>启动docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>停止docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>查看服务状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>开机自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h1 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h1><h2 id="列出本机镜像：docker-images"><a href="#列出本机镜像：docker-images" class="headerlink" title="列出本机镜像：docker images"></a>列出本机镜像：docker images</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="表头说明"><a href="#表头说明" class="headerlink" title="表头说明"></a>表头说明</h3><ul>
<li>REPOSITORY：镜像的名称</li>
<li>TAG：镜像的版本号</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<h3 id="OPTIONS说明"><a href="#OPTIONS说明" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -q</span><br></pre></td></tr></table></figure>

<ul>
<li>-q：只显示镜像ID</li>
<li>–no-trunc :显示完整的镜像ID</li>
</ul>
<h2 id="查找镜像：docker-search"><a href="#查找镜像：docker-search" class="headerlink" title="查找镜像：docker search"></a>查找镜像：docker search</h2><h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172002980.png" alt="image-20230713172002980"></p>
<h3 id="表头说明-1"><a href="#表头说明-1" class="headerlink" title="表头说明"></a>表头说明</h3><ul>
<li>NAME：镜像的名称</li>
<li>DESCRIPTION：镜像描述</li>
<li>STARS：点赞数量</li>
<li>OFFICIAL：是否是官方镜像</li>
<li>AUTOMATED：是否自动化构建，只要代码版本管理网站的项目有更新, 就会触发自动创建image.</li>
</ul>
<h3 id="OPTIONS说明-1"><a href="#OPTIONS说明-1" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search -s 30 tomcat</span><br><span class="line">#或</span><br><span class="line">docker search --filter=stars=30 tomcat</span><br></pre></td></tr></table></figure>

<ul>
<li>-s：列出收藏数不小于指定值的镜像</li>
<li>–filter : 过滤器</li>
</ul>
<h2 id="下载镜像：docker-pull"><a href="#下载镜像：docker-pull" class="headerlink" title="下载镜像：docker pull"></a>下载镜像：docker pull</h2><h3 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<p>使用 docker images查看镜像列表，可以看到tomcat的体积非常大，因为这是一个独立的集装箱环境，包含了所有运行tomcat所必须的底层依赖。</p>
<p><img src="/img/image-20230713172017746.png" alt="image-20230713172017746"></p>
<h3 id="下载指定版本"><a href="#下载指定版本" class="headerlink" title="下载指定版本"></a>下载指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#例如</span><br><span class="line">docker pull redis:3.2</span><br></pre></td></tr></table></figure>

<h2 id="删除镜像：docker-rmi"><a href="#删除镜像：docker-rmi" class="headerlink" title="删除镜像：docker rmi"></a>删除镜像：docker rmi</h2><h3 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi tomcat</span><br><span class="line">docker rmi reids:3.2 #删除指定版本的镜像</span><br><span class="line">docker rmi 镜像id #根据镜像id删除镜像</span><br></pre></td></tr></table></figure>

<h3 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f hello-world #强制删除已经创建了实例的镜像，此时再次运行实例会重新下载镜像</span><br></pre></td></tr></table></figure>

<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi tomcat redis #删除多个镜像，使用空格间隔不同的镜像名称</span><br><span class="line">docker rmi -f $(docker images -q) #删除所有镜像</span><br></pre></td></tr></table></figure>

<h2 id="查看镜像详情：docker-inspect"><a href="#查看镜像详情：docker-inspect" class="headerlink" title="查看镜像详情：docker inspect"></a>查看镜像详情：docker inspect</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect tomcat:8.5.32 | grep -i version #查看镜像的具体版本，-i：忽略大小写</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172028732.png" alt="image-20230713172028732"></p>
<h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><h2 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="列出容器：docker-ps"><a href="#列出容器：docker-ps" class="headerlink" title="列出容器：docker ps"></a>列出容器：docker ps</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps #列出所有正在运行的容器，不包含已停止的容器</span><br><span class="line">docker ps -a #列出当前所有已经创建的容器</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/2020/08/07/23-43-39.png"><img src="https://cdn.xn2001.com/2020/08/07/23-43-39.png" alt="img"></a></p>
<h3 id="表头说明-2"><a href="#表头说明-2" class="headerlink" title="表头说明"></a>表头说明</h3><ul>
<li>CONTAINER ID：容器id</li>
<li>IMAGE：创建容器的镜像</li>
<li>COMMAND：容器启动调用的命令</li>
<li>CREATED：容器创建时间</li>
<li>STATUS：容器的状态（Created&#x2F;创建&#x2F;Up启动&#x2F;Exited退出）</li>
<li>PORTS：容器占用的端口</li>
<li>NAMES：容器名</li>
</ul>
<h3 id="OPTIONS说明-2"><a href="#OPTIONS说明-2" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -qa #列出所有容器的编号</span><br></pre></td></tr></table></figure>

<ul>
<li>-a ：列出当前所有已经创建的容器</li>
<li>-l ：显示最近创建的一个容器</li>
<li>-n：显示最近n个创建的容器。 docker ps -n 3</li>
<li>-q：只显示容器编号</li>
</ul>
<h2 id="创建容器：docker-create"><a href="#创建容器：docker-create" class="headerlink" title="创建容器：docker create"></a>创建容器：docker create</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker create tomcat #根据镜像名创建一个容器</span><br><span class="line">docker create --name tomcat1 tomcat ##根据镜像名创建一个容器，并为容器起一个别名tomcat1</span><br><span class="line">docker create 镜像id #根据镜像id新建一个容器</span><br></pre></td></tr></table></figure>

<h2 id="启动容器：docker-start"><a href="#启动容器：docker-start" class="headerlink" title="启动容器：docker start"></a>启动容器：docker start</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start tomcat1 #根据容器名启动一个容器</span><br><span class="line">docker start 容器id #根据容器id启动一个容器</span><br></pre></td></tr></table></figure>

<h2 id="创建并启动容器：docker-run"><a href="#创建并启动容器：docker-run" class="headerlink" title="创建并启动容器：docker run"></a>创建并启动容器：docker run</h2><p>相当于 docker create + docker start</p>
<p>当本地镜像不存在时，相当于 docker pull + docker create + docker start</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run tomcat #根据镜像名创建一个容器，并启动</span><br><span class="line">docker run --name tomcat2 tomcat #为容器起一个别名tomcat2，并启动</span><br></pre></td></tr></table></figure>

<h2 id="停止容器：docker-stop"><a href="#停止容器：docker-stop" class="headerlink" title="停止容器：docker stop"></a>停止容器：docker stop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop tomcat1 #根据容器名停止一个容器</span><br></pre></td></tr></table></figure>

<h2 id="强制停止容易：docker-kill"><a href="#强制停止容易：docker-kill" class="headerlink" title="强制停止容易：docker kill"></a>强制停止容易：docker kill</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill tomcat1 #根据容器名强制停止一个容器</span><br></pre></td></tr></table></figure>

<h2 id="重启容器：docker-restart"><a href="#重启容器：docker-restart" class="headerlink" title="重启容器：docker restart"></a>重启容器：docker restart</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart tomcat2 #根据容器名重启一个容器</span><br></pre></td></tr></table></figure>

<h2 id="删除容器：docker-rm"><a href="#删除容器：docker-rm" class="headerlink" title="删除容器：docker rm"></a>删除容器：docker rm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm tomcat1 #删除未启动的容器 </span><br><span class="line">docker rm -f tomcat2 #强制删除已启动的容器</span><br><span class="line">docker rm -f $(docker ps -qa) #删除所有容器</span><br></pre></td></tr></table></figure>

<h2 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h2><p>启动CentOS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos</span><br></pre></td></tr></table></figure>

<p>默认情况下，centos启动后无事可做，docker会立即停止刚刚启动的centos容器，如下图：</p>
<p>使用 <strong>docker run centos</strong> 运行一个centos容器，随即使用 <strong>docker ps</strong> 列出正在运行的容器列表，未发现刚刚运行的centos；</p>
<p>使用 <strong>docker ps -a</strong> 列出全部容器列表，发现centos容器已停止</p>
<p><img src="/img/image-20230713172044184.png" alt="image-20230713172044184"></p>
<h3 id="交互式启动：-it"><a href="#交互式启动：-it" class="headerlink" title="交互式启动：-it"></a>交互式启动：-it</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name centos1 centos #启动后，当前命令行会进入到centos容器内部</span><br></pre></td></tr></table></figure>

<h3 id="OPTIONS说明-3"><a href="#OPTIONS说明-3" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><ul>
<li>-i：保持容器一直运行，但命令行会挂起，通常与 -t 同时使用；</li>
<li>-t：为容器分配一个伪输入终端，通常与 -i 同时使用；</li>
</ul>
<p>此时可以像在本地服务器上一样在容器内执行Linux命令，例如查看内核版本号、查看Linux发行版本号等</p>
<p>（如果在宿主机上也查看内核版本号，那么可以发现容器使用的是宿主机的内核）</p>
<p><img src="/img/image-20230713172107944.png" alt="image-20230713172107944"></p>
<h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><h3 id="容器不停止退出"><a href="#容器不停止退出" class="headerlink" title="容器不停止退出"></a>容器不停止退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+p, q #容器不停止退出，此时执行docker ps，可以看到centos还在运行</span><br></pre></td></tr></table></figure>

<h3 id="容器停止并退出"><a href="#容器停止并退出" class="headerlink" title="容器停止并退出"></a>容器停止并退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit #容器停止退出，此时执行docker ps -a，发现centos已停止</span><br></pre></td></tr></table></figure>

<h2 id="进入容器：docker-attach"><a href="#进入容器：docker-attach" class="headerlink" title="进入容器：docker attach"></a>进入容器：docker attach</h2><p>当容器未停止时，在宿主机中可以进入到容器内部命令行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach centos1</span><br></pre></td></tr></table></figure>

<h3 id="执行命令：docker-exec"><a href="#执行命令：docker-exec" class="headerlink" title="执行命令：docker exec"></a>执行命令：docker exec</h3><p>在容器外部执行命令，使命令在容器内部运行，并返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#确保容器是启动状态，并且当前命令行在容器外部的宿主机上</span><br><span class="line">docker exec -it centos1 cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

<p>比较下面两个命令的执行结果：第一个显示的是centos容器的版本，第二个显示的是宿主机centos的版本</p>
<p><img src="/img/image-20230713172152900.png" alt="image-20230713172152900"></p>
<h2 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h2><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><p>默认情况下，tomcat的启动会占用当前命令行窗口，并进入挂起状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run tomcat</span><br></pre></td></tr></table></figure>

<h3 id="守护式启动：-d"><a href="#守护式启动：-d" class="headerlink" title="守护式启动：-d"></a>守护式启动：-d</h3><p>我们可以以守护进程的方式启动tomcat容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name tomcat1 tomcat  #在后台启动tomcat，不占用命令行资源</span><br></pre></td></tr></table></figure>

<h3 id="映射容器端口：-p"><a href="#映射容器端口：-p" class="headerlink" title="映射容器端口：-p"></a>映射容器端口：-p</h3><p>默认情况下，我们无法通过docker所在的宿主机访问tomcat容器的8080端口，需要将8080端口映射到宿主机的某一个端口上</p>
<p><img src="/img/image-20230713172211376.png" alt="image-20230713172211376"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P tomcat #（大写P）随机端口映射</span><br><span class="line">docker run -d -p 7777:8080 --name tomcat2 tomcat #（小写P）将容器端口发布到主机7777端口</span><br><span class="line">docker inspect tomcat2 #inspect可以用于镜像，也可以用于容器，这里可以查看容器tomcat2的详情</span><br></pre></td></tr></table></figure>

<h3 id="OPTIONS说明-4"><a href="#OPTIONS说明-4" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><ul>
<li>-P: 随机端口映射；</li>
<li>-p: 指定端口映射，有以下四种格式<ul>
<li>ip:hostPort:containerPort</li>
<li>hostPort:containerPort</li>
<li>ip::containerPort：主机随机分配端口映射容器的指定端口</li>
<li>containerPort：主机随机分配端口映射容器的指定端口</li>
</ul>
</li>
</ul>
<p>访问前面启动的tomcat容器：如 <a target="_blank" rel="noopener" href="http://192.168.100.101:9999/">http://192.168.100.101:7777</a>，发现报告404错误，</p>
<p>原因是docker latest版本的tomcat下的webapps中没有部署任何默认项目，因此启动浏览器无法访问tomcat默认主页面</p>
<h2 id="执行命令：docker-exec-1"><a href="#执行命令：docker-exec-1" class="headerlink" title="执行命令：docker exec"></a>执行命令：docker exec</h2><p>进入到容器内部的文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat2 /bin/bash</span><br></pre></td></tr></table></figure>

<p>下载8.5.32版本的docker tomcat镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+p, q #退出tomcat容器</span><br><span class="line">docker pull tomcat:8.5.32</span><br><span class="line">docker run -d -p 8888:8080 --name tomcat3 tomcat:8.5.32</span><br></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://192.168.100.101:7777/">http://192.168.100.101:8888</a> ，可以看到tomcat的默认主页</p>
<h2 id="查看容器详情：docker-inspect"><a href="#查看容器详情：docker-inspect" class="headerlink" title="查看容器详情：docker inspect"></a>查看容器详情：docker inspect</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect tomcat3</span><br></pre></td></tr></table></figure>

<h1 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h1><h2 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h2><p>出于效率等一系列原因，docker 容器的文件系统在宿主机上存在的方式很复杂，这会带来下面几个问题：</p>
<ul>
<li>当容器删除时，容器中产生的数据将丢失：例如，MySQL容器损坏无法启动，需要删除容器重新创建，那么数据库数据将会丢失</li>
</ul>
<img src="/img/image-20230713172227368.png" alt="image-20230713172227368" style="zoom:50%;" />





<ul>
<li>无法在多个容器之间共享数据：</li>
</ul>
<p>例如，Tomcat集群部署成功后，无法共享程序文件</p>
<img src="/img/image-20230713172305559.png" alt="image-20230713172305559" style="zoom:50%;" />



<h2 id="数据卷的概念"><a href="#数据卷的概念" class="headerlink" title="数据卷的概念"></a>数据卷的概念</h2><p>为了解决以上的问题，docker 引入了数据卷(volume) 机制。数据卷是存在于一个或多个容器中的特定文件或文件夹，这个文件或文件夹以独立于 docker 文件系统的形式存在于宿主机中。</p>
<ul>
<li><p>当容器删除时，容器中的数据可以被持久化：</p>
<p><img src="/img/image-20230713172327531.png" alt="image-20230713172327531"></p>
</li>
<li><p>在多个容器之间共享数据：</p>
<p><img src="/img/image-20230713172340461.png" alt="image-20230713172340461"></p>
</li>
</ul>
<p>数据卷的最大特点是：其生存周期独立于容器的生存周期。使用数据卷可以在多个容器之间共享数据。</p>
<h2 id="配置数据卷目录"><a href="#配置数据卷目录" class="headerlink" title="配置数据卷目录"></a>配置数据卷目录</h2><h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><p>将宿主机根目录中的dataVolumeHost挂载到容器根目录中的dataVolumeContainer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dataVolumeHost:/dataVolumeContainer --name centos2 centos:7</span><br></pre></td></tr></table></figure>

<h3 id="OPTIONS说明-5"><a href="#OPTIONS说明-5" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><ul>
<li>-v：挂载数据卷</li>
<li>格式：&#x2F;宿主机目录(文件):&#x2F;容器内目录(文件)</li>
<li>目录必须是绝对路径</li>
<li>如果目录不存在，则自动创建</li>
<li>可以挂载多个数据卷</li>
</ul>
<h2 id="查看数据卷是否挂载成功"><a href="#查看数据卷是否挂载成功" class="headerlink" title="查看数据卷是否挂载成功"></a>查看数据卷是否挂载成功</h2><p>此时可以分别查看宿主机和容器的根目录，发现分别生成了数据卷目录</p>
<p><img src="/img/image-20230713172518015.png" alt="image-20230713172518015"></p>
<p>执行命令 <strong>docker inspect</strong> 可以查看数据卷已挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect centos2</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172529171.png" alt="image-20230713172529171"></p>
<h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><p>首先进入容器，在容器的数据卷挂载目录中创建文件并写入内容</p>
<p>然后退出容器，查看宿主机挂载目录，可以看到同步更新的文件</p>
<p><img src="/img/image-20230713172546548.png" alt="image-20230713172546548"></p>
<h2 id="数据的同步"><a href="#数据的同步" class="headerlink" title="数据的同步"></a>数据的同步</h2><p>首先停止容器</p>
<p>然后在宿主机修改共享数据</p>
<p>接下来启动前面的容器，查看共享数据文件，发现数据在容器中同步</p>
<p><img src="/img/image-20230713172601509.png" alt="image-20230713172601509"></p>
<h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><p>首先删除容器</p>
<p>然后在宿主机修改共享数据</p>
<p>接着重新创建容器并挂载数据卷</p>
<p>发现数据在容器中恢复</p>
<p><img src="/img/image-20230713172614434.png" alt="image-20230713172614434"></p>
<h2 id="一个容器挂载多个数据卷"><a href="#一个容器挂载多个数据卷" class="headerlink" title="一个容器挂载多个数据卷"></a>一个容器挂载多个数据卷</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">-v /dataVolumeHost31:/dataVolumeContainer31 \</span><br><span class="line">-v /dataVolumeHost32:/dataVolumeContainer32 \</span><br><span class="line">--name centos3 centos:7</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172627624.png" alt="image-20230713172627624"></p>
<h2 id="两个容器挂载同一个数据卷"><a href="#两个容器挂载同一个数据卷" class="headerlink" title="两个容器挂载同一个数据卷"></a>两个容器挂载同一个数据卷</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dataVolumeHost:/dataVolumeContainer4 --name centos4 centos:7</span><br><span class="line">docker run -it -v /dataVolumeHost:/dataVolumeContainer5 --name centos5 centos:7</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172643157.png" alt="image-20230713172643157"></p>
<h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><h2 id="什么是数据卷容器"><a href="#什么是数据卷容器" class="headerlink" title="什么是数据卷容器"></a>什么是数据卷容器</h2><h3 id="多容器数据交换的方式"><a href="#多容器数据交换的方式" class="headerlink" title="多容器数据交换的方式"></a>多容器数据交换的方式</h3><ul>
<li>多个容器挂载宿主机上的同一个数据卷目录</li>
<li>多个容器挂载宿主机上的同一个数据卷容器<ul>
<li>首先将宿主机上的数据卷目录挂载到容器1上</li>
<li>然后将容器1挂载到容器2和容器3上</li>
<li>此时宿主机上的数据卷目录就会自动挂载到容器2和容3上，即使容器3宕机，也不会影响其他两个容器的运行</li>
</ul>
</li>
</ul>
<img src="/img/image-20230713172712256.png" alt="image-20230713172712256" style="zoom:50%;" />

<h3 id="数据卷容器的概念"><a href="#数据卷容器的概念" class="headerlink" title="数据卷容器的概念"></a>数据卷容器的概念</h3><p>数据卷容器也是一个容器，但是这个容器的作用是专门提供数据卷供其他容器挂载，其它容器通过挂载这个数据卷容器实现数据共享。</p>
<h2 id="配置数据卷容器"><a href="#配置数据卷容器" class="headerlink" title="配置数据卷容器"></a>配置数据卷容器</h2><h3 id="创建数据卷容器"><a href="#创建数据卷容器" class="headerlink" title="创建数据卷容器"></a>创建数据卷容器</h3><p>当 -v 参数后面只有一个目录的时候，表示只设置容器中的数据卷目录，而宿主机中的数据卷目录会被自动分配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /volume --name c1 centos:7</span><br></pre></td></tr></table></figure>

<p>容器创建成功后，可以查看数据卷目录的分配情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect c1</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172730945.png" alt="image-20230713172730945"></p>
<h3 id="挂载数据卷容器"><a href="#挂载数据卷容器" class="headerlink" title="挂载数据卷容器"></a>挂载数据卷容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from c1 --name c2 centos:7</span><br><span class="line">docker run -it --volumes-from c1 --name c3 centos:7</span><br></pre></td></tr></table></figure>

<h3 id="OPTIONS说明-6"><a href="#OPTIONS说明-6" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h3><p>–volumes-from：将当前容器挂载到指定的数据卷容器上</p>
<p>容器创建成功后，可以查看c1和c2的数据卷目录的分配情况，发现和c1使用的是同一个宿主机的文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect c2</span><br><span class="line">docker inspect c3</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172748194.png" alt="image-20230713172748194"></p>
<p><img src="/img/image-20230713172804298.png" alt="image-20230713172804298"></p>
<h3 id="测试数据共享"><a href="#测试数据共享" class="headerlink" title="测试数据共享"></a>测试数据共享</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /var/lib/docker/volumes/06e480611281a60059aeb574dc2b455645d896858d7c7a849c65cf2113a35df3/_data/data.txt # 写入 hello volume container</span><br><span class="line">docker exec -it c2 cat /volume/data.txt</span><br><span class="line">docker exec -it c3 cat /volume/data.txt</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172818313.png" alt="image-20230713172818313"></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>Docker-Compose项目是Docker官方的开源项目，<strong>负责实现对Docker容器集群的快速编排。</strong></p>
<p>Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。</p>
<p>Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。</p>
<p>一个服务当中可包括多个容器实例，<strong>Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。</strong></p>
<p>Docker-Compose的工程配置文件默认为 <code>docker-compose.yml</code>，当然也可以通过环境变量 <code>COMPOSE_FILE</code> 或 <code>-f</code> 参数自定义配置文件。</p>
<p>使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br><span class="line">docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>

<p>命令选项：</p>
<ul>
<li>-f –file： FILE指定Compose模板文件，默认为docker-compose.yml</li>
<li>-p –project-name： NAME 指定项目名称，默认使用当前所在目录为项目名</li>
<li>–verbose： 输出更多调试信息</li>
<li>-v，-version： 打印版本并退出</li>
<li>–log-level LEVEL： 定义日志等级(DEBUG, INFO, WARNING, ERROR, CRITICAL)</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>启动docker-compose：<code>docker-compose up -d</code></p>
<p>列出所有容器：<code>docker-compose ps</code></p>
<p>停止容器：<code>docker-compose stop</code> 停止正在运行的容器，可以通过 <code>docker-compose start</code> 再次启动</p>
<p>查看日志：<code>docker-compose logs</code></p>
<p>重启所有容器：<code>docker-compose restart</code></p>
<p>暂停某个容器：<code>docker-compose pause [SERVICE...]</code></p>
<p>进入某个容器：<code>docker-compose exec [options] SERVICE COMMAND [ARGS...]</code></p>
<p>选项包括：</p>
<ul>
<li>-d 分离模式，后台运行命令。</li>
<li>–privileged 获取特权。</li>
<li>–user USER 指定运行的用户。</li>
</ul>
<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>Compose允许用户通过一个 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Compose模板文件是一个定义服务、网络和卷的YAML文件。Compose模板文件默认路径是当前目录下的 <code>docker-compose.yml</code>，可以使用 <code>.yml</code> 或 <code>.yaml</code> 作为文件扩展名。</p>
<p><strong>Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services部分。</strong></p>
<p>注意：yml 语法的格式是非常重要的，缩进也要得当。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services: </span><br><span class="line">  mysql1:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: mysql1</span><br><span class="line">    environment: </span><br><span class="line">      - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    ports: </span><br><span class="line">     - 39111:3306</span><br><span class="line"></span><br><span class="line">  mysql2:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: mysql2</span><br><span class="line">    environment: </span><br><span class="line">      - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    ports: </span><br><span class="line">       - 39112:3306</span><br></pre></td></tr></table></figure>

<p><img src="/img/image-20230713172833841.png" alt="image-20230713172833841"></p>
<p>其中还有一些比较常用的属性</p>
<p><strong>depends_on</strong></p>
<p>在使用Compose时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。<strong>depends_on标签用于解决容器的依赖、启动先后的问题</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>

<p>上述YAML文件定义的容器会先启动 redis 和 db 两个服务，最后才启动 web 服务。</p>
<p><strong>volumes</strong></p>
<p>挂载数据卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /opt/data:/var/lib/mysql</span><br></pre></td></tr></table></figure>

<p><strong>volumes_from</strong></p>
<p>挂载数据卷容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes_from:</span><br><span class="line">  - service_name   </span><br><span class="line">    - container_name</span><br></pre></td></tr></table></figure>

<p><strong>links</strong></p>
<p>链接到其它服务中的容器。在 Redis 搭建主从架构时我便使用到了它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  - db</span><br><span class="line">  - db:database</span><br><span class="line">  - redis</span><br></pre></td></tr></table></figure>

<p><strong>build</strong></p>
<p>服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。</p>
<p>Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build: /path/to/build/dir</span><br></pre></td></tr></table></figure>

<p>　也可以是相对路径，只要上下文确定就可以读取到Dockerfile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br></pre></td></tr></table></figure>

<p>　设定上下文根目录，然后以该目录为准指定Dockerfile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: ../</span><br><span class="line">  dockerfile: path/of/Dockerfile</span><br></pre></td></tr></table></figure>

<p>如果同时指定image和build两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 值指定的名字。</p>
<h1 id="实际操作案例"><a href="#实际操作案例" class="headerlink" title="实际操作案例"></a>实际操作案例</h1><h2 id="内网镜像拉取"><a href="#内网镜像拉取" class="headerlink" title="内网镜像拉取"></a>内网镜像拉取</h2><blockquote>
<p>​     很多时候，我们只有内网环境，没有外网环境，不能方便的拉取镜像文件，这个时候我们可以借助外网环境将镜像拉取下来然后再拷贝到内网环境中去。</p>
<p>​    外网环境拉取你想要的镜像文件，以jdk:8为案例：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拉取镜像</span><br><span class="line">docker pull openjdk:8</span><br><span class="line">将镜像当成tar包  下面两种方式都是可以的 标签/或者imageId(这个就直接复制你pull下来的那个messageId就行了)</span><br><span class="line">docker save -o openjdk8.tar openjdk:8</span><br><span class="line">docker save -o openjdk8.tar imageId</span><br></pre></td></tr></table></figure>

<p>openjdk8.tar这个文件会在你打包的当前目录下面存在的，你在什么目录下面打包，他就在哪个目录下。</p>
<p>然后将这个tar包下载下来，放到内网环境的服务器上，内网服务器安装docker就不赘述了。然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i openjdk8.tar</span><br></pre></td></tr></table></figure>

<p>这样就可以了，然后通过下面命令查看有没有执行成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>找到对应的标签就说明执行成功了。这就完成了一个外网环境将镜像迁移到内网环境中去的操作。</p>
<h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a><strong>编写Dockerfile</strong></h2><p>此时我们已经拥有了，基础镜像文件，我们要将这个镜像文件打包成我们需要的镜像文件，也就是将我们的Java程序丢进去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"># 工作目录</span><br><span class="line">WORKDIR /opt/javaapps/pis-ats-interface</span><br><span class="line"></span><br><span class="line"># 复制配置文件到容器中</span><br><span class="line">COPY application.yml /opt/javaapps/pis-ats-interface/</span><br><span class="line"></span><br><span class="line"># 复制 Jar 文件到容器的对应目录中去</span><br><span class="line">COPY app.jar /opt/javaapps/pis-ats-interface/</span><br><span class="line"></span><br><span class="line"># 暴露容器的端口</span><br><span class="line">EXPOSE 9889</span><br><span class="line"></span><br><span class="line"># 指定运行 Jar 文件的命令</span><br><span class="line">CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/opt/javaapps/pis-ats-interface/app.jar&quot;, &quot;--spring.config.name=application&quot;, &quot;--server.port=9889&quot;,&quot;&amp;&quot;]</span><br></pre></td></tr></table></figure>

<p>简单的Dockerfile就完成了，此时我们需要将Dockerfile重新构建成一份新的镜像文件</p>
<p>构建成镜像文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法如下</span><br><span class="line">docker build -t &lt;镜像名称&gt; &lt;Dockerfile路径&gt;</span><br><span class="line"># 实例  java8是我对镜像的命名 .表示在当前目录下  下面一个是表示含有具体目录  不需要将Dockerfile文件写出 他默认找这个文件的</span><br><span class="line">docker build -t java8 .</span><br><span class="line">docker build -t java8 /opt/javaapps/pis-ats-interface/</span><br></pre></td></tr></table></figure>

<p>此时已经自定义完成了一个新的镜像文件 <strong>java8</strong>，有了镜像就需要去创建一个新的容器了，由于我们是要运行我们的java项目，那么肯定是需要将端口映射到主机外部的，所以我们启动的时候则需要开放出端口来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 语法  将9889的内部端口映射到外部端口 8888 中去</span><br><span class="line">docker run -d --name my-container -p 8888:9889 my-image</span><br><span class="line"># 实例  这里我是创建了一个java8的镜像创建了一个java8的容器，并且是后台运行的，在将9889端口映射到9889端口上去</span><br><span class="line">docker run -d --name java8 -p 9889:9889 java8</span><br></pre></td></tr></table></figure>

<p>至此就完成了一个服务的运行。</p>
<p>服务运行起来了，我们就需要查看日志，就需要进入到内部容器中去（此时我还没有做挂载数据卷的操作）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法 </span><br><span class="line">docker exec -it my-app-container bash</span><br><span class="line"># 实例 我的容器名称是java8  </span><br><span class="line">docker exec -it java8 bash</span><br><span class="line"># 然后就可以进入到文件目录查看自己系统产生的日志文件了  这个根据你的log4j或者其他框架 看你的文件具体产生在哪</span><br></pre></td></tr></table></figure>

<p>还有一点就是docker也会产生日志文件的，我们系统产生的日志会由 Docker 守护进程捕获并记录到宿主机的日志系统中。所以我们可以直接查看docker的日志，从而去看我们系统上的日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">docker logs 容器名称</span><br><span class="line"># 实例</span><br><span class="line">docker logs java8</span><br></pre></td></tr></table></figure>

<p>那么问题就出现了，这样docker的日志就会越来越多，我们在系统会有限制日志的产生，但docker本身不会呀，所以我们就需要去限制docker的日志量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 修改docker配置</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">#  添加如下信息 </span><br><span class="line">&#123;</span><br><span class="line">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;: &#123;</span><br><span class="line">        &quot;max-size&quot;: &quot;10m&quot;,</span><br><span class="line">        &quot;max-file&quot;:&quot;3&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>提示：添加之后仅对后面创建的容器生效，对之前的容器并不生效，所以需要删了之前的容器，重新创建。</p>
<p>从上面的操作就能看出这样启动一个程序效率低下，而且不能主动的去内外端口映射，十分麻烦，所以我们就需要安装docker  compose。</p>
<p>外网操作的相关已经在之前的进行相应的表述。接下来学习内网的操作。</p>
<h2 id="Docker-Compose的实战应用"><a href="#Docker-Compose的实战应用" class="headerlink" title="Docker Compose的实战应用"></a><strong>Docker Compose的实战应用</strong></h2><p>离线安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64</span><br></pre></td></tr></table></figure>

<p>将下载的文件传到内网服务器上 目录自己决定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>

<p>这就完成了安装了，版本内容就自己看。接下来就是编写docker-compose.yml文件。</p>
<p>我们可以使用镜像进行编写yml文件，也可以直接使用Dockerfile进行编写yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"># 在docker-compose命令中需要用到这个名称</span><br><span class="line">  java8:</span><br><span class="line">  # 使用镜像文件进行编写yml  这是我自己构建的一个镜像文件</span><br><span class="line">    image: java8</span><br><span class="line">    ports:</span><br><span class="line">    # 开放映射端口</span><br><span class="line">      - 9889:9889</span><br><span class="line">      - 7667:7667</span><br><span class="line">      # 容器名称 这个是根据你自己想给你的服务取什么名字的</span><br><span class="line">    container_name: java8</span><br><span class="line">    # 当遇到了出现崩溃错误的时候会自动重启</span><br><span class="line">    restart: always</span><br><span class="line">    # 挂载数据卷 将容器内的/var/log/pis-ats-interface 挂载到宿主机/opt/datas/atslog中去</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/datas/atslog:/var/log/pis-ats-interface</span><br></pre></td></tr></table></figure>

<p>这样一个简单的docker-compose.yml就写完了，然后需要注意的是，这个文件在哪目录下，哪个目录才能执行相应的命令。</p>
<p>比如我在 &#x2F;opt&#x2F;java目录下 有docker-compose.yml文件 我只能在这个目录下才能运行<strong>docker-compose up -d</strong>命令， -d是表示后台运行。</p>
<p>下面是一些相关命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 执行启动程序</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"># 启动已存在但停止的所有service 前提是这个容器已经存在 所以才有这个服务</span><br><span class="line">docker-compose start [serviceName]</span><br><span class="line"></span><br><span class="line"># 停止运行的service ， serviceName（可选）：表示停止某一个service</span><br><span class="line">docker-compose stop [serviceName]</span><br><span class="line"></span><br><span class="line"># ：删除已停止的所有service  -f ：删除不在询问 （可选）serviceName：表示删除已停止某一个service</span><br><span class="line">docker-compose rm -f [serviceName]</span><br><span class="line"></span><br><span class="line"># 执行关闭程序</span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line">#  -v ：删除挂载卷和volunme的链接</span><br><span class="line">* docker-compose down -v</span><br><span class="line"></span><br><span class="line"># 查看服务内所有容器日志输出，加上serviceName表示输出某一个service的日志</span><br><span class="line">* docker-compose logs [serviceName]</span><br><span class="line"></span><br><span class="line">#  实时输出日志 </span><br><span class="line">docker-compose run service command</span><br><span class="line"></span><br><span class="line"># 实例 java8 是我的服务名称  后面的是容器内产生的日志路径文件</span><br><span class="line">docker-compose run java8 tail -f /opt/ats/ats-info.log</span><br><span class="line"></span><br><span class="line"># 进入到某个容器</span><br><span class="line">docker-compose exec [serviceName] sh </span><br><span class="line"></span><br><span class="line"># 重启服务</span><br><span class="line">docker-compose restart [serviceName]</span><br><span class="line"></span><br><span class="line"># 验证和查看compose文件</span><br><span class="line">docker-compose config</span><br><span class="line"></span><br><span class="line"># 列出所用的镜像</span><br><span class="line">docker-compose images</span><br><span class="line"></span><br><span class="line"># 设置服务个数 Eg：docker-compose scale web=2 worker=3 </span><br><span class="line">docker-cpmpose scale</span><br><span class="line"></span><br><span class="line"># 暂停服务</span><br><span class="line">docker-compose pause [serviceName]</span><br><span class="line"></span><br><span class="line"># 恢复服务</span><br><span class="line">docker-compose unpause [serviceName]</span><br></pre></td></tr></table></figure>

<h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a><strong>环境变量设置</strong></h2><p>上面提到我们每次只能在有docker-compose.yml文件的目录下才能使用docker-compose的相关命令，这样就很麻烦，所以需要去配置下所谓的环境变量。<strong>通过设置 alias 别名（环境变量）来实现 docker-compose 命令在任意路径下可执行。</strong></p>
<p>Linux 中 alias 命令用来设置指令的别名，通常用于对一些较长的命令进行简化。它的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias [别名]=&#x27;原命令 -选项/参数&#x27;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll=&#x27;ls -lt&#x27;</span><br></pre></td></tr></table></figure>

<p>那么让 docker-compose 命令在任意路径下都能使用的设置方法如下： vim ~&#x2F;.bashrc，加入一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias docker-compose=&#x27;cd /data/soft/harbor;docker-compose&#x27;</span><br></pre></td></tr></table></figure>

<p>保存退出，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>查看已经设置的别名列表，此时能看到 docker-compose 已经设置，然后就可以在任何目录下都能运行docker-compose命令了。</p>
<h2 id="多个服务运行"><a href="#多个服务运行" class="headerlink" title="多个服务运行"></a><strong>多个服务运行</strong></h2><p>docker-compose运行单个服务的规则已经讲完，现在就要运行多个服务的了，一般运行多个服务，我们肯定需要一些环境，比如MySQL、Redis、消息中间件（eg:RabbitMq）、注册中心（Nacos）等。所以就需要之前提及到的知识点。<strong>depends_on来解决容器的依赖、启动先后的问题</strong>。</p>
<p>比如下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql_data:/var/lib/mysql</span><br><span class="line">      - ./mysql_logs:/var/log/mysql</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    environment:</span><br><span class="line">      - REDIS_PASSWORD=123456</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis_data:/data</span><br><span class="line">      - ./redis_logs:/var/log/redis</span><br><span class="line"></span><br><span class="line">  rabbitmq:</span><br><span class="line">    image: rabbitmq</span><br><span class="line">    ports:</span><br><span class="line">      - 5672:5672</span><br><span class="line">      - 15672:15672</span><br><span class="line">    environment:</span><br><span class="line">      - RABBITMQ_DEFAULT_USER=guest</span><br><span class="line">      - RABBITMQ_DEFAULT_PASS=guest</span><br><span class="line">    volumes:</span><br><span class="line">      - ./rabbitmq_data:/var/lib/rabbitmq</span><br><span class="line">      - ./rabbitmq_logs:/var/log/rabbitmq</span><br><span class="line"></span><br><span class="line">  nacos:</span><br><span class="line">    image: nacos/nacos-server</span><br><span class="line">    ports:</span><br><span class="line">      - 8848:8848</span><br><span class="line">    environment:</span><br><span class="line">      - MODE=standalone</span><br><span class="line">      - SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">      - MYSQL_SERVICE_HOST=mysql</span><br><span class="line">      - MYSQL_SERVICE_PORT=3306</span><br><span class="line">      - MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">      - MYSQL_SERVICE_USERNAME=root</span><br><span class="line">      - MYSQL_SERVICE_PASSWORD=123456</span><br><span class="line">    volumes:</span><br><span class="line">      - ./nacos_data:/home/nacos/data</span><br><span class="line">      - ./nacos_logs:/var/log/nacos</span><br><span class="line"></span><br><span class="line">  java9:</span><br><span class="line">    image: java9</span><br><span class="line">    ports:</span><br><span class="line">      - 9887:9887</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">      - redis</span><br><span class="line">      - rabbitmq</span><br><span class="line">      - nacos</span><br><span class="line"></span><br><span class="line">  java10:</span><br><span class="line">    image: java10</span><br><span class="line">    ports:</span><br><span class="line">      - 9888:9888</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">      - redis</span><br><span class="line">      - rabbitmq</span><br><span class="line">      - nacos</span><br></pre></td></tr></table></figure>

<p><strong>具名挂载方式：</strong></p>
<p><img src="/img/image-20230712221940580-16892093918302.png" alt="image-20230712221940580"></p>
<p><strong>匿名挂载方式：</strong></p>
<p><img src="/img/image-20230712222425432-16892093773341.png" alt="image-20230712222425432"></p>
<p>这是两种挂载的方式，建议推荐使用上面的一个。</p>
<p><strong>tips：</strong>一般如果权限不足可以加上root用户上去，如下，在jenkins上就使用了root用户。<br>“root”是指使用Jenkins的根用户。这意味着具有根权限的用户正在执行或配置Jenkins的相关操作。通常情况下，根用户具有系统的最高权限，并且可以执行各种特权操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  java8:</span><br><span class="line">    image: java8</span><br><span class="line">    ports:</span><br><span class="line">      - 9889:9889</span><br><span class="line">      - 7667:7667</span><br><span class="line">    container_name: java8</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/datas/atslog:/var/log/pis-ats-interface:rw,delegated,size=200kb</span><br><span class="line">  jenkins:</span><br><span class="line">    user: root     </span><br><span class="line">    image: jenkins/jenkins:lts</span><br><span class="line">    ports:</span><br><span class="line">      - 8999:8080</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/datas/jenkins/home:/var/jenkins_home</span><br><span class="line">      - /opt/datas/jenkins/log:/var/log/jenkins</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://ashleyye.top">joywu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ashleyye.top/2023/03/14/docker%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/">http://ashleyye.top/2023/03/14/docker知识介绍/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ashleyye.top" target="_blank">Ashley的个人博客空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/25/%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="解决项目中数据不一致问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解决项目中数据不一致问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">joywu</div><div class="author-info__description">余生有你,幸莫大焉</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/wzl0258"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wzl0258" target="_blank" title="Gitee"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">哈喽，欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E6%8B%AC"><span class="toc-number">1.</span> <span class="toc-text">基本概括</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">容器背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序运行的基础环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">解决方案：容器化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">Docker概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%90%86%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">Docker理念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">安装准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">前提条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CentOS7-%E9%95%9C%E5%83%8F"><span class="toc-number">2.2.</span> <span class="toc-text">CentOS7 镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">2.3.</span> <span class="toc-text">查看系统内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BCentOS%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.</span> <span class="toc-text">查看CentOS版本信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CentOS7%E5%AE%89%E8%A3%85Docker"><span class="toc-number">3.</span> <span class="toc-text">CentOS7安装Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">3.1.</span> <span class="toc-text">安装需要的软件包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%8B%E8%BD%BD"><span class="toc-number">3.2.</span> <span class="toc-text">Docker下载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.</span> <span class="toc-text">更新yum软件包索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker-CE"><span class="toc-number">3.4.</span> <span class="toc-text">安装Docker CE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Docker"><span class="toc-number">3.5.</span> <span class="toc-text">启动Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E8%87%AA%E5%90%AF"><span class="toc-number">3.6.</span> <span class="toc-text">Docker自启</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%AA%8C%E8%AF%81"><span class="toc-number">3.7.</span> <span class="toc-text">版本验证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CentOS6-8%E5%AE%89%E8%A3%85docker"><span class="toc-number">4.</span> <span class="toc-text">CentOS6.8安装docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85epel"><span class="toc-number">4.1.</span> <span class="toc-text">安装epel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">安装后的配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Docker-1"><span class="toc-number">4.3.</span> <span class="toc-text">启动Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%AA%8C%E8%AF%81-1"><span class="toc-number">4.4.</span> <span class="toc-text">版本验证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDDocker"><span class="toc-number">5.</span> <span class="toc-text">卸载Docker</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E6%9E%B6%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">Docker架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">6.1.</span> <span class="toc-text">架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%BB%84%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">架构组成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.</span> <span class="toc-text">容器镜像服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%80%9A%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.2.</span> <span class="toc-text">开通镜像服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hello-world"><span class="toc-number">8.</span> <span class="toc-text">hello-world</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#run%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">run的工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">Docker基本命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">11.</span> <span class="toc-text">Docker镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E9%95%9C%E5%83%8F%EF%BC%9Adocker-images"><span class="toc-number">11.1.</span> <span class="toc-text">列出本机镜像：docker images</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">11.1.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%A4%B4%E8%AF%B4%E6%98%8E"><span class="toc-number">11.1.2.</span> <span class="toc-text">表头说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E"><span class="toc-number">11.1.3.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F%EF%BC%9Adocker-search"><span class="toc-number">11.2.</span> <span class="toc-text">查找镜像：docker search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%A4%B4%E8%AF%B4%E6%98%8E-1"><span class="toc-number">11.2.2.</span> <span class="toc-text">表头说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-1"><span class="toc-number">11.2.3.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%EF%BC%9Adocker-pull"><span class="toc-number">11.3.</span> <span class="toc-text">下载镜像：docker pull</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-2"><span class="toc-number">11.3.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC"><span class="toc-number">11.3.2.</span> <span class="toc-text">下载指定版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%EF%BC%9Adocker-rmi"><span class="toc-number">11.4.</span> <span class="toc-text">删除镜像：docker rmi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-3"><span class="toc-number">11.4.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4"><span class="toc-number">11.4.2.</span> <span class="toc-text">强制删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4"><span class="toc-number">11.4.3.</span> <span class="toc-text">批量删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E8%AF%A6%E6%83%85%EF%BC%9Adocker-inspect"><span class="toc-number">11.5.</span> <span class="toc-text">查看镜像详情：docker inspect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">12.</span> <span class="toc-text">Docker容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-4"><span class="toc-number">12.1.</span> <span class="toc-text">基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-ps"><span class="toc-number">12.1.1.</span> <span class="toc-text">列出容器：docker ps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%A4%B4%E8%AF%B4%E6%98%8E-2"><span class="toc-number">12.1.2.</span> <span class="toc-text">表头说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-2"><span class="toc-number">12.1.3.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-create"><span class="toc-number">12.2.</span> <span class="toc-text">创建容器：docker create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-start"><span class="toc-number">12.3.</span> <span class="toc-text">启动容器：docker start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-run"><span class="toc-number">12.4.</span> <span class="toc-text">创建并启动容器：docker run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-stop"><span class="toc-number">12.5.</span> <span class="toc-text">停止容器：docker stop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E6%98%93%EF%BC%9Adocker-kill"><span class="toc-number">12.6.</span> <span class="toc-text">强制停止容易：docker kill</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-restart"><span class="toc-number">12.7.</span> <span class="toc-text">重启容器：docker restart</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-rm"><span class="toc-number">12.8.</span> <span class="toc-text">删除容器：docker rm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">12.9.</span> <span class="toc-text">启动交互式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%AF%E5%8A%A8%EF%BC%9A-it"><span class="toc-number">12.9.1.</span> <span class="toc-text">交互式启动：-it</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-3"><span class="toc-number">12.9.2.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">12.10.</span> <span class="toc-text">退出容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8D%E5%81%9C%E6%AD%A2%E9%80%80%E5%87%BA"><span class="toc-number">12.10.1.</span> <span class="toc-text">容器不停止退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%81%9C%E6%AD%A2%E5%B9%B6%E9%80%80%E5%87%BA"><span class="toc-number">12.10.2.</span> <span class="toc-text">容器停止并退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%EF%BC%9Adocker-attach"><span class="toc-number">12.11.</span> <span class="toc-text">进入容器：docker attach</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%9Adocker-exec"><span class="toc-number">12.11.1.</span> <span class="toc-text">执行命令：docker exec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">12.12.</span> <span class="toc-text">启动守护式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8tomcat"><span class="toc-number">12.12.1.</span> <span class="toc-text">启动tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%90%AF%E5%8A%A8%EF%BC%9A-d"><span class="toc-number">12.12.2.</span> <span class="toc-text">守护式启动：-d</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%EF%BC%9A-p"><span class="toc-number">12.12.3.</span> <span class="toc-text">映射容器端口：-p</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-4"><span class="toc-number">12.12.4.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%9Adocker-exec-1"><span class="toc-number">12.13.</span> <span class="toc-text">执行命令：docker exec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%AF%A6%E6%83%85%EF%BC%9Adocker-inspect"><span class="toc-number">12.14.</span> <span class="toc-text">查看容器详情：docker inspect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">13.</span> <span class="toc-text">Docker数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">13.1.</span> <span class="toc-text">什么是数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">13.2.</span> <span class="toc-text">数据卷的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9B%AE%E5%BD%95"><span class="toc-number">13.3.</span> <span class="toc-text">配置数据卷目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">13.3.1.</span> <span class="toc-text">挂载数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-5"><span class="toc-number">13.3.2.</span> <span class="toc-text">OPTIONS说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%98%AF%E5%90%A6%E6%8C%82%E8%BD%BD%E6%88%90%E5%8A%9F"><span class="toc-number">13.4.</span> <span class="toc-text">查看数据卷是否挂载成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">13.5.</span> <span class="toc-text">数据共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">13.6.</span> <span class="toc-text">数据的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">13.7.</span> <span class="toc-text">数据的持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">13.8.</span> <span class="toc-text">一个容器挂载多个数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">13.9.</span> <span class="toc-text">两个容器挂载同一个数据卷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">14.1.</span> <span class="toc-text">什么是数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">14.1.1.</span> <span class="toc-text">多容器数据交换的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">14.1.2.</span> <span class="toc-text">数据卷容器的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">14.2.</span> <span class="toc-text">配置数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">14.2.1.</span> <span class="toc-text">创建数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">14.2.2.</span> <span class="toc-text">挂载数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B4%E6%98%8E-6"><span class="toc-number">14.2.3.</span> <span class="toc-text">OPTIONS说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">14.2.4.</span> <span class="toc-text">测试数据共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">15.</span> <span class="toc-text">Docker-Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.1.</span> <span class="toc-text">概念介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85docker-compose"><span class="toc-number">15.2.</span> <span class="toc-text">安装docker-compose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">15.3.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose-yml"><span class="toc-number">15.4.</span> <span class="toc-text">docker-compose.yml</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">16.</span> <span class="toc-text">实际操作案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96"><span class="toc-number">16.1.</span> <span class="toc-text">内网镜像拉取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99Dockerfile"><span class="toc-number">16.2.</span> <span class="toc-text">编写Dockerfile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Compose%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8"><span class="toc-number">16.3.</span> <span class="toc-text">Docker Compose的实战应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">16.4.</span> <span class="toc-text">环境变量设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C"><span class="toc-number">16.5.</span> <span class="toc-text">多个服务运行</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/14/docker%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/" title="Docker从零开始">Docker从零开始</a><time datetime="2023-03-14T10:00:00.000Z" title="发表于 2023-03-14 18:00:00">2023-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/25/%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="解决项目中数据不一致问题">解决项目中数据不一致问题</a><time datetime="2023-02-25T10:00:00.000Z" title="发表于 2023-02-25 18:00:00">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/14/MySql/" title="MySql短记">MySql短记</a><time datetime="2022-12-14T10:00:00.000Z" title="发表于 2022-12-14 18:00:00">2022-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/24/%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/" title="解决项目前端页面响应问题">解决项目前端页面响应问题</a><time datetime="2022-10-24T10:00:00.000Z" title="发表于 2022-10-24 18:00:00">2022-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/05/Netty%E4%B8%8E%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9B%B8%E8%AF%86/" title="Netty快速入门">Netty快速入门</a><time datetime="2022-08-05T10:00:00.000Z" title="发表于 2022-08-05 18:00:00">2022-08-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By joywu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>